package live.step0;

public class Intro {
  private void whyDidTheyNeedToChangeJavaAgain() {
    // *Java 1.0 was released in January 1996*

    // The world of programming has changed: *the rise of multicore CPUs*

    // The *java.util.concurrent* package (and external libraries) have developed a variety of *concurrency abstractions*
    // - that begin to help programmers write code that performs well on multicore CPUs.
    // - Unfortunately, there are limits to the level of abstractions that library writers can use in Java today.
    // - A good example of this is the lack of efficient parallel operations over large collections

    // There are *other benefits* to this new abstraction as well. For many of us who aren’t writing
    // performance-critical code all the time, these are more important wins. You can write
    // *easier-to-read code*—code that spends time *expressing the intent of its business logic
    // rather than the mechanics of how it’s achieved*.
  }

  private void whatIsFunctionalProgramming() {
    // At the heart of functional programming is thinking about your problem domain in terms
    // of immutable values and functions that translate between them.

    // It’s a bit too early to tell how Java programmers will define functional programming

    // What we really care about is writing good code rather than functional code
  }
}
